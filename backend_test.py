#!/usr/bin/env python3
"""
Backend Test Suite for Game Master Manager
Tests the backend API endpoints as specified in the review request
"""

import requests
import json
import sys
import os
from datetime import datetime

# Get backend URL from frontend .env file
def get_backend_url():
    try:
        with open('/app/frontend/.env', 'r') as f:
            for line in f:
                if line.startswith('REACT_APP_BACKEND_URL='):
                    return line.split('=', 1)[1].strip()
    except FileNotFoundError:
        return "http://localhost:8001"
    return "http://localhost:8001"

BACKEND_URL = get_backend_url()
API_BASE = f"{BACKEND_URL}/api"

class BackendTester:
    def __init__(self):
        self.results = []
        self.total_tests = 0
        self.passed_tests = 0
        
    def log_result(self, test_name, success, message, details=None):
        """Log test result"""
        self.total_tests += 1
        if success:
            self.passed_tests += 1
            status = "✅ PASS"
        else:
            status = "❌ FAIL"
            
        result = {
            "test": test_name,
            "status": status,
            "message": message,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        self.results.append(result)
        print(f"{status}: {test_name} - {message}")
        if details:
            print(f"   Details: {details}")
    
    def test_server_startup(self):
        """Test 1: Vérifier que l'API démarre correctement sur le port configuré"""
        try:
            response = requests.get(f"{API_BASE}/", timeout=10)
            if response.status_code == 200:
                data = response.json()
                if "message" in data:
                    self.log_result("Server Startup", True, f"API accessible at {API_BASE}")
                    return True
                else:
                    self.log_result("Server Startup", False, "API accessible but unexpected response format", data)
                    return False
            else:
                self.log_result("Server Startup", False, f"HTTP {response.status_code}", response.text[:200])
                return False
        except requests.exceptions.RequestException as e:
            self.log_result("Server Startup", False, f"Connection failed: {str(e)}")
            return False
    
    def test_basic_routes(self):
        """Test 2: Tester les routes de base"""
        # Test root endpoint
        try:
            response = requests.get(f"{API_BASE}/", timeout=5)
            if response.status_code == 200:
                self.log_result("Basic Route - Root", True, "Root endpoint working")
            else:
                self.log_result("Basic Route - Root", False, f"HTTP {response.status_code}")
        except Exception as e:
            self.log_result("Basic Route - Root", False, f"Error: {str(e)}")
    
    def test_game_events_available(self):
        """Test 3: Tester /api/games/events/available"""
        try:
            response = requests.get(f"{API_BASE}/games/events/available", timeout=5)
            if response.status_code == 200:
                data = response.json()
                if isinstance(data, list) and len(data) > 0:
                    # Check if events have required fields
                    first_event = data[0]
                    required_fields = ['id', 'name', 'type', 'difficulty', 'description']
                    missing_fields = [field for field in required_fields if field not in first_event]
                    
                    if not missing_fields:
                        self.log_result("Game Events Available", True, f"Found {len(data)} events with correct structure")
                    else:
                        self.log_result("Game Events Available", False, f"Events missing fields: {missing_fields}", first_event)
                else:
                    self.log_result("Game Events Available", False, "Empty or invalid events list", data)
            else:
                self.log_result("Game Events Available", False, f"HTTP {response.status_code}", response.text[:200])
        except Exception as e:
            self.log_result("Game Events Available", False, f"Error: {str(e)}")
    
    def test_generate_players(self):
        """Test 4: Tester la génération de joueurs aléatoires avec count=10"""
        try:
            response = requests.post(f"{API_BASE}/games/generate-players?count=10", timeout=10)
            if response.status_code == 200:
                data = response.json()
                if isinstance(data, list) and len(data) == 10:
                    # Check first player structure
                    first_player = data[0]
                    required_fields = ['id', 'number', 'name', 'nationality', 'gender', 'role', 'stats', 'portrait', 'uniform']
                    missing_fields = [field for field in required_fields if field not in first_player]
                    
                    if not missing_fields:
                        # Check stats structure
                        stats = first_player.get('stats', {})
                        stats_fields = ['intelligence', 'force', 'agilite']
                        missing_stats = [field for field in stats_fields if field not in stats]
                        
                        if not missing_stats:
                            self.log_result("Generate Players", True, f"Generated 10 players with correct structure")
                        else:
                            self.log_result("Generate Players", False, f"Player stats missing fields: {missing_stats}", stats)
                    else:
                        self.log_result("Generate Players", False, f"Player missing fields: {missing_fields}", first_player)
                else:
                    self.log_result("Generate Players", False, f"Expected 10 players, got {len(data) if isinstance(data, list) else 'non-list'}", data)
            else:
                self.log_result("Generate Players", False, f"HTTP {response.status_code}", response.text[:200])
        except Exception as e:
            self.log_result("Generate Players", False, f"Error: {str(e)}")
    
    def test_create_game(self):
        """Test 5: Tester la création de parties avec des joueurs de base"""
        try:
            # Create a basic game request
            game_request = {
                "player_count": 20,
                "game_mode": "standard",
                "selected_events": [1, 2, 3],  # First 3 events
                "manual_players": []
            }
            
            response = requests.post(f"{API_BASE}/games/create", 
                                   json=game_request, 
                                   headers={"Content-Type": "application/json"},
                                   timeout=15)
            
            if response.status_code == 200:
                data = response.json()
                required_fields = ['id', 'players', 'events', 'current_event_index', 'completed']
                missing_fields = [field for field in required_fields if field not in data]
                
                if not missing_fields:
                    players_count = len(data.get('players', []))
                    events_count = len(data.get('events', []))
                    
                    if players_count == 20 and events_count == 3:
                        self.log_result("Create Game", True, f"Game created with {players_count} players and {events_count} events")
                        return data.get('id')  # Return game ID for further testing
                    else:
                        self.log_result("Create Game", False, f"Wrong counts - players: {players_count}, events: {events_count}")
                else:
                    self.log_result("Create Game", False, f"Game missing fields: {missing_fields}", data)
            else:
                self.log_result("Create Game", False, f"HTTP {response.status_code}", response.text[:200])
        except Exception as e:
            self.log_result("Create Game", False, f"Error: {str(e)}")
        
        return None
    
    def test_simulate_event(self, game_id=None):
        """Test 6: Tester la simulation d'événements"""
        if not game_id:
            # Try to create a game first
            game_id = self.test_create_game()
            if not game_id:
                self.log_result("Simulate Event", False, "No game available for testing")
                return
        
        try:
            response = requests.post(f"{API_BASE}/games/{game_id}/simulate-event", timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if 'result' in data and 'game' in data:
                    result = data['result']
                    game = data['game']
                    
                    # Check result structure
                    result_fields = ['event_id', 'event_name', 'survivors', 'eliminated', 'total_participants']
                    missing_result_fields = [field for field in result_fields if field not in result]
                    
                    if not missing_result_fields:
                        survivors_count = len(result.get('survivors', []))
                        eliminated_count = len(result.get('eliminated', []))
                        total = result.get('total_participants', 0)
                        
                        if survivors_count + eliminated_count == total:
                            self.log_result("Simulate Event", True, 
                                          f"Event simulated: {survivors_count} survivors, {eliminated_count} eliminated")
                        else:
                            self.log_result("Simulate Event", False, 
                                          f"Participant count mismatch: {survivors_count}+{eliminated_count}≠{total}")
                    else:
                        self.log_result("Simulate Event", False, f"Result missing fields: {missing_result_fields}")
                else:
                    self.log_result("Simulate Event", False, "Response missing 'result' or 'game' fields", data)
            else:
                self.log_result("Simulate Event", False, f"HTTP {response.status_code}", response.text[:200])
        except Exception as e:
            self.log_result("Simulate Event", False, f"Error: {str(e)}")
    
    def test_pydantic_models(self):
        """Test 7: Vérifier que les modèles Pydantic sont corrects via les réponses API"""
        # This is tested implicitly through other tests, but we can add specific validation
        try:
            # Test player generation to validate Player model
            response = requests.post(f"{API_BASE}/games/generate-players?count=1", timeout=5)
            if response.status_code == 200:
                data = response.json()
                if len(data) == 1:
                    player = data[0]
                    # Validate player model structure
                    expected_structure = {
                        'id': str,
                        'number': str,
                        'name': str,
                        'nationality': str,
                        'gender': str,
                        'role': str,
                        'stats': dict,
                        'portrait': dict,
                        'uniform': dict,
                        'alive': bool,
                        'kills': int,
                        'betrayals': int,
                        'survived_events': int,
                        'total_score': int
                    }
                    
                    validation_errors = []
                    for field, expected_type in expected_structure.items():
                        if field not in player:
                            validation_errors.append(f"Missing field: {field}")
                        elif not isinstance(player[field], expected_type):
                            validation_errors.append(f"Wrong type for {field}: expected {expected_type.__name__}, got {type(player[field]).__name__}")
                    
                    if not validation_errors:
                        self.log_result("Pydantic Models", True, "Player model structure validated")
                    else:
                        self.log_result("Pydantic Models", False, "Player model validation failed", validation_errors)
                else:
                    self.log_result("Pydantic Models", False, "Could not get single player for validation")
            else:
                self.log_result("Pydantic Models", False, f"Could not test models - HTTP {response.status_code}")
        except Exception as e:
            self.log_result("Pydantic Models", False, f"Error: {str(e)}")
    
    def test_full_names_generation(self):
        """Test CRITICAL: Vérifier que les joueurs ont des noms complets (prénom + nom de famille) cohérents avec leur nationalité"""
        try:
            # Test 1: Generate 20 players and check name format
            response = requests.post(f"{API_BASE}/games/generate-players?count=20", timeout=10)
            
            if response.status_code != 200:
                self.log_result("Full Names Generation", False, f"Could not generate players - HTTP {response.status_code}")
                return
                
            players = response.json()
            
            if len(players) != 20:
                self.log_result("Full Names Generation", False, f"Expected 20 players, got {len(players)}")
                return
            
            # Check each player has full name format
            name_format_errors = []
            nationality_consistency_errors = []
            name_variety = set()
            
            for player in players:
                name = player.get('name', '')
                nationality = player.get('nationality', '')
                
                # Check name format (should have at least first name + last name)
                name_parts = name.strip().split()
                if len(name_parts) < 2:
                    name_format_errors.append(f"Player {player.get('number', 'unknown')}: '{name}' - only has {len(name_parts)} part(s)")
                else:
                    # Check for variety
                    name_variety.add(name)
                    
                    # Check nationality consistency for specific nationalities
                    first_name = name_parts[0]
                    last_name = name_parts[-1]
                    
                    # Define expected patterns for specific nationalities
                    nationality_patterns = {
                        'Coréenne': {
                            'first_names': ['Min-jun', 'Seo-jun', 'Do-yoon', 'Si-woo', 'Joon-ho', 'Hyun-woo', 'Jin-woo', 'Sung-min',
                                          'Seo-yeon', 'Min-seo', 'Ji-woo', 'Ha-eun', 'Soo-jin', 'Ye-jin', 'Su-bin', 'Na-eun'],
                            'last_names': ['Kim', 'Lee', 'Park', 'Choi', 'Jung', 'Kang', 'Cho', 'Yoon', 'Jang', 'Lim', 'Han', 'Oh']
                        },
                        'Japonaise': {
                            'first_names': ['Hiroshi', 'Takeshi', 'Akira', 'Yuki', 'Daiki', 'Haruto', 'Sota', 'Ren',
                                          'Sakura', 'Yuki', 'Ai', 'Rei', 'Mana', 'Yui', 'Hina', 'Emi'],
                            'last_names': ['Sato', 'Suzuki', 'Takahashi', 'Tanaka', 'Watanabe', 'Ito', 'Yamamoto', 'Nakamura', 'Kobayashi', 'Kato', 'Yoshida', 'Yamada']
                        },
                        'Française': {
                            'first_names': ['Pierre', 'Jean', 'Michel', 'Alain', 'Philippe', 'Nicolas', 'Antoine', 'Julien',
                                          'Marie', 'Nathalie', 'Isabelle', 'Sylvie', 'Catherine', 'Valérie', 'Christine', 'Sophie'],
                            'last_names': ['Martin', 'Bernard', 'Thomas', 'Petit', 'Robert', 'Richard', 'Durand', 'Dubois', 'Moreau', 'Laurent', 'Simon', 'Michel']
                        },
                        'Américaine': {
                            'first_names': ['John', 'Michael', 'David', 'James', 'Robert', 'William', 'Christopher', 'Matthew',
                                          'Mary', 'Jennifer', 'Linda', 'Patricia', 'Susan', 'Jessica', 'Sarah', 'Karen'],
                            'last_names': ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez', 'Hernandez', 'Lopez']
                        },
                        'Chinoise': {
                            'first_names': ['Wei', 'Jun', 'Ming', 'Hao', 'Lei', 'Qiang', 'Yang', 'Bin',
                                          'Li', 'Wang', 'Zhang', 'Liu', 'Chen', 'Yang', 'Zhao', 'Huang'],
                            'last_names': ['Wang', 'Li', 'Zhang', 'Liu', 'Chen', 'Yang', 'Zhao', 'Huang', 'Zhou', 'Wu', 'Xu', 'Sun']
                        }
                    }
                    
                    if nationality in nationality_patterns:
                        pattern = nationality_patterns[nationality]
                        if first_name not in pattern['first_names'] or last_name not in pattern['last_names']:
                            nationality_consistency_errors.append(
                                f"Player {player.get('number', 'unknown')}: '{name}' (nationality: {nationality}) - "
                                f"first name '{first_name}' or last name '{last_name}' doesn't match nationality patterns"
                            )
            
            # Evaluate results
            success = True
            messages = []
            
            if name_format_errors:
                success = False
                messages.append(f"Name format errors: {len(name_format_errors)} players don't have full names")
                for error in name_format_errors[:3]:  # Show first 3 errors
                    messages.append(f"  - {error}")
            
            if nationality_consistency_errors:
                # This is a warning, not a failure, as some nationalities might use fallback names
                messages.append(f"Nationality consistency warnings: {len(nationality_consistency_errors)} potential mismatches")
                for error in nationality_consistency_errors[:2]:  # Show first 2 warnings
                    messages.append(f"  - {error}")
            
            # Check name variety
            if len(name_variety) < len(players) * 0.8:  # At least 80% unique names
                messages.append(f"Low name variety: only {len(name_variety)} unique names out of {len(players)} players")
            
            if success:
                self.log_result("Full Names Generation", True, 
                              f"✅ All 20 players have proper full names. Unique names: {len(name_variety)}/20")
            else:
                self.log_result("Full Names Generation", False, 
                              f"❌ Name format issues found", messages)
            
            # Test 2: Test with game creation to ensure consistency
            print("   Testing full names in game creation...")
            game_request = {
                "player_count": 20,
                "game_mode": "standard",
                "selected_events": [1, 2, 3],
                "manual_players": []
            }
            
            response = requests.post(f"{API_BASE}/games/create", 
                                   json=game_request, 
                                   headers={"Content-Type": "application/json"},
                                   timeout=15)
            
            if response.status_code == 200:
                game_data = response.json()
                game_players = game_data.get('players', [])
                
                game_name_errors = []
                for player in game_players:
                    name = player.get('name', '')
                    name_parts = name.strip().split()
                    if len(name_parts) < 2:
                        game_name_errors.append(f"Game player {player.get('number', 'unknown')}: '{name}' - incomplete name")
                
                if game_name_errors:
                    self.log_result("Full Names in Game Creation", False, 
                                  f"❌ Game creation has name format issues", game_name_errors[:3])
                else:
                    self.log_result("Full Names in Game Creation", True, 
                                  f"✅ All players in created game have proper full names")
            else:
                self.log_result("Full Names in Game Creation", False, 
                              f"Could not test game creation - HTTP {response.status_code}")
                
        except Exception as e:
            self.log_result("Full Names Generation", False, f"Error during test: {str(e)}")

    def test_one_survivor_condition(self):
        """Test CRITICAL: Vérifier que le jeu s'arrête à 1 survivant (pas 0)"""
        try:
            # Create a game with 20 players for testing (minimum required)
            game_request = {
                "player_count": 20,
                "game_mode": "standard", 
                "selected_events": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],  # Multiple events
                "manual_players": []
            }
            
            response = requests.post(f"{API_BASE}/games/create", 
                                   json=game_request, 
                                   headers={"Content-Type": "application/json"},
                                   timeout=15)
            
            if response.status_code != 200:
                self.log_result("One Survivor Condition", False, f"Could not create test game - HTTP {response.status_code}")
                return
                
            game_data = response.json()
            game_id = game_data.get('id')
            
            if not game_id:
                self.log_result("One Survivor Condition", False, "No game ID returned from creation")
                return
            
            # Simulate events until game ends
            max_events = 20  # Safety limit
            event_count = 0
            final_survivors = 0
            game_completed = False
            winner_found = False
            
            while event_count < max_events:
                event_count += 1
                
                # Simulate one event
                response = requests.post(f"{API_BASE}/games/{game_id}/simulate-event", timeout=10)
                
                if response.status_code != 200:
                    self.log_result("One Survivor Condition", False, 
                                  f"Event simulation failed at event {event_count} - HTTP {response.status_code}")
                    return
                
                data = response.json()
                game = data.get('game', {})
                result = data.get('result', {})
                
                # Count current survivors
                survivors = result.get('survivors', [])
                final_survivors = len(survivors)
                game_completed = game.get('completed', False)
                winner = game.get('winner')
                winner_found = winner is not None
                
                print(f"   Event {event_count}: {final_survivors} survivors, completed: {game_completed}")
                
                # If game is completed, check the conditions
                if game_completed:
                    if final_survivors == 1:
                        if winner_found:
                            self.log_result("One Survivor Condition", True, 
                                          f"✅ Game correctly stopped at 1 survivor after {event_count} events. Winner properly set.")
                        else:
                            self.log_result("One Survivor Condition", False, 
                                          f"Game stopped at 1 survivor but no winner was set")
                    elif final_survivors == 0:
                        self.log_result("One Survivor Condition", False, 
                                      f"❌ CRITICAL: Game continued until 0 survivors (old behavior)")
                    else:
                        self.log_result("One Survivor Condition", False, 
                                      f"Game stopped with {final_survivors} survivors (unexpected)")
                    return
                
                # If we have 1 survivor but game is not completed, that's an error
                if final_survivors == 1 and not game_completed:
                    self.log_result("One Survivor Condition", False, 
                                  f"❌ CRITICAL: 1 survivor remaining but game not marked as completed")
                    return
                
                # If we have 0 survivors, the game should have ended before this
                if final_survivors == 0:
                    self.log_result("One Survivor Condition", False, 
                                  f"❌ CRITICAL: Game reached 0 survivors without stopping at 1")
                    return
            
            # If we exit the loop without the game completing
            self.log_result("One Survivor Condition", False, 
                          f"Game did not complete after {max_events} events. Final survivors: {final_survivors}")
            
        except Exception as e:
            self.log_result("One Survivor Condition", False, f"Error during test: {str(e)}")

    def check_backend_logs(self):
        """Check backend logs for errors"""
        try:
            # Try to read supervisor logs
            log_files = [
                "/var/log/supervisor/backend.out.log",
                "/var/log/supervisor/backend.err.log"
            ]
            
            errors_found = []
            for log_file in log_files:
                if os.path.exists(log_file):
                    with open(log_file, 'r') as f:
                        lines = f.readlines()[-50:]  # Last 50 lines
                        for line in lines:
                            if any(keyword in line.lower() for keyword in ['error', 'exception', 'traceback', 'failed']):
                                errors_found.append(f"{log_file}: {line.strip()}")
            
            if errors_found:
                self.log_result("Backend Logs", False, f"Found {len(errors_found)} error entries", errors_found[:5])
            else:
                self.log_result("Backend Logs", True, "No critical errors found in recent logs")
                
        except Exception as e:
            self.log_result("Backend Logs", False, f"Could not check logs: {str(e)}")
    
    def run_all_tests(self):
        """Run all backend tests"""
        print(f"🚀 Starting Backend Tests for Game Master Manager")
        print(f"📍 Backend URL: {BACKEND_URL}")
        print(f"📍 API Base: {API_BASE}")
        print("=" * 60)
        
        # Test 1: Server startup
        if not self.test_server_startup():
            print("\n❌ Server not accessible - stopping tests")
            return self.generate_summary()
        
        # Test 2: Basic routes
        self.test_basic_routes()
        
        # Test 3: Game events
        self.test_game_events_available()
        
        # Test 4: Player generation
        self.test_generate_players()
        
        # Test 5: Game creation
        game_id = self.test_create_game()
        
        # Test 6: Event simulation
        self.test_simulate_event(game_id)
        
        # Test 7: Model validation
        self.test_pydantic_models()
        
        # Test 8: CRITICAL - One survivor condition (NEW TEST)
        print("\n🎯 Testing CRITICAL fix: 1 survivor condition...")
        self.test_one_survivor_condition()
        
        # Check logs
        self.check_backend_logs()
        
        return self.generate_summary()
    
    def generate_summary(self):
        """Generate test summary"""
        print("\n" + "=" * 60)
        print("📊 TEST SUMMARY")
        print("=" * 60)
        print(f"Total Tests: {self.total_tests}")
        print(f"Passed: {self.passed_tests}")
        print(f"Failed: {self.total_tests - self.passed_tests}")
        print(f"Success Rate: {(self.passed_tests/self.total_tests*100):.1f}%" if self.total_tests > 0 else "0%")
        
        print("\n📋 DETAILED RESULTS:")
        for result in self.results:
            print(f"{result['status']}: {result['test']}")
            if result['status'] == "❌ FAIL":
                print(f"   → {result['message']}")
        
        # Critical issues
        critical_failures = [r for r in self.results if r['status'] == "❌ FAIL" and 
                           any(keyword in r['test'].lower() for keyword in ['server', 'startup', 'basic'])]
        
        if critical_failures:
            print(f"\n🚨 CRITICAL ISSUES FOUND: {len(critical_failures)}")
            for failure in critical_failures:
                print(f"   • {failure['test']}: {failure['message']}")
        
        return {
            "total_tests": self.total_tests,
            "passed_tests": self.passed_tests,
            "success_rate": (self.passed_tests/self.total_tests*100) if self.total_tests > 0 else 0,
            "results": self.results,
            "critical_failures": len(critical_failures)
        }

if __name__ == "__main__":
    tester = BackendTester()
    summary = tester.run_all_tests()
    
    # Exit with error code if tests failed
    if summary["critical_failures"] > 0 or summary["success_rate"] < 50:
        sys.exit(1)
    else:
        sys.exit(0)